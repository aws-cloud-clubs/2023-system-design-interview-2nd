## 분산 시스템을 위한 유일 ID 생성기 설계

auto_increment 속성을 지닌 를 사용해 유일ID를 판별할 시 분산 환경이나 다닝 ㄹ서버일 경우에 수많은 요구를 감당하지 못 할 뿐더러 여러 데이터베이스 서버를 쓰는 경우 지연 시간을 낮추기가 무척 힘들다.

### 선택 가능한 선택지

- 다중 마스터 복제 (multi-master replication)
- UUID (Universallly Unique Identifier)
- 티켓 서버 (ticket server)
- 트위터 스노플레이크 (twitter snowflake) 접근법

#### 다중 마스터 복제

이 접근법은 데이터베이스의 auto_increment 기능을 활용하는 것이다. 다만 ID값을 구할 때 1 만큼 증가시켜 구하는 것이 아니라 k만큼 증가시킨다.

여기서 k는 현재 사용 중ㅇ인 데이터베이스 서버의 수다. 어떤 서버가 만들어 낼 다음 아이디는 해당 서버가 생성한 이전 ID값에 전체 서버의 수 2를 더한 값이다.

EX) Server 1 : 1,3,5,.. ==> 웹서버로 전송 , Server 2 : 2,4,6 ... ===> 웹서버로 전송

하지만 해당 방법은 다음과 같은 중대한 단점이 있다.

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
- ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수 없다.
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.

#### UUID

UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수다.
UUID 값은 충돌 가능성이 지극히 낮다. UUID는 서버 간 조율 없이 독립적으로 생성 가능하다.

<b>장점</b>

- UUID를 만드는 것은 단순하다. 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.

<b>단점</b>

- ID가 128비트로 길다.
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자가 아닌 값이 포함될 수 있다.

#### 티켓 서버

해당 아이디어의 핵심은 auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다.

<b>장점</b>

- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고 중소 규모 어플리케이션에 적합하다.

<b>단점</b>

- 티켓 서버가 SPOF(Single - Point - of - Failure)가 된다. 이 서버에 장애가 발생하며 해당 서버를 이용하는 모든 시스템이 영향을 받는다. 이 이슈를 피하려면 티켓 서버를 여러 대 준비해야 한다. 하지만 그렇게 하면 데이터 동기화 같은 새로운 문제가 발생한다.

#### 트위터 스노플레이크 접근법

생성해야 하는 ID의 구조를 여러 절(section)으로 분할 하는 방법이다. 해당 섹션의 구성 요소는 다음과 같다.

<img src="https://velog.velcdn.com/images/kshired/post/52f86757-0fbf-44b7-b733-5b183a121783/image.png>

- 사인(sign) 비트 : 1비트 할당. 지금으로서는 쓰임새가 당장에는 없지만 나중을 위해 유보해 둔다. 음수/양수를 구별하는 데 사용 할 수 있다.

- 타임스탬프(timestamp): 41비트를 할당한다. 기원 시각(epoch) 이후로 몇 밀리초가 경과했는지를 나타내는 값이다.

- 데이터센터 ID: 5비트를 할당한다. 따라서 2^5=32개 데이터센터를 지원할 수 있다.

- 서버 ID : 5비트를 할당한다. 따라서 데이터센터당 32개 서버를 사용할 수 있다.

- 일련번호: 12비트를 할당한다. 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1만큼 증가시킨다. 이 값은 1밀리초가 경과할 때마다 0으로 초기화된다.

<b> 타임스탬프 </b>

타임스탬프는 앞서 살펴본 ID구조에서 가장 중요한 41비트를 차지하고 있다. 타임스탬프는 시간이 흐름에 따라 점점 큰 값을 갖게 되므로, 결국 ID는 시간순으로 졍렬 가능하게 될 것이다. 밑의 그림은 앞서 살펴본 ID구조를 따르는 값의 이진 표현 형태로부터 UTC 시각을 추출하는 예제다. 이 방법을 역으로 적용하면 어떤 UTC 시각도 상술한 타임스탬프 값으로 변환할 수 있다.

<img src="https://velog.velcdn.com/images/kshired/post/e146b607-2921-4a80-a361-3ed7fb38019f/image.png">

41비트로 표현할 수 있는 타임스탬프의 최댓값은 2^41-1 = 2199023255551밀리 초이다. 이 값은 대략 69년에 해당한다. 따라서 이 ID생성기는 69년만 정상 동작한다. 69년이 지나면 기원 시각을 바꾸거나 ID체계를 다른 것으로 이전 하여야한다.

<b> 일련번호 </b>

일련번호는 12비트이므로 2^12=4096개의 값을 가질 수 있다. 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.

#### 추가 논의 가능 지점

- 시계 동기화
- 각 절(seciton)의 길이 최적화

## URL 단축기 설계

### API 엔드 포인트

URL 단축기는 기본적으로 두 개의 엔드포인트를 필요로 한다.

1. URL 단축용 엔드포인트 : 새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 실어서 POST요청을 보내야 한다. 이 엔드포인트는 다음과 같은 형태를 띤다.

POST /api/v1/data/shorten

- 인자: {longUrl: longURLstring}
- 반환 : 단축 URL

--> 긴 URL을 단축 URL로 변환하는 것이 목적.

2. URL 디리렉션용 엔드포인트: 단축 URL에 대해서 HTTP요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트. 다음과 같은 형태를 띤다.

GET /api/v1/shortUrl

- 반환 : HTTP 리디렉션 목적지가 될 원래 URL

### URL 리디렉션

브라우저에 단축 URL을 입력하면 무슨 일이 생기는지 살펴보자.

<img src="https://velog.velcdn.com/images/kshired/post/51096530-08ec-4e29-a6f4-6b7571c394d4/image.png">

단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어서 301 응답의 Location 헤더에 넣어 반환한다.

다음 그림은 클라이언트와 서버의 통신 절차를 좀 더 자세히 보여준다.

<img src="https://velog.velcdn.com/images/kshired/post/24ec867e-e940-4b88-9dfe-55284657da22/image.png">

여기서 유의할 것은 301 응답과 302 응답의 차이이다. 둘 다 리디렉션 응답이긴 하지만 차이가 있다.

- 301 Permanently Moved: 이 응답은 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답이다. 영구적으로 이전되었으므로, "브라우저"는 이 응답을 캐시한다. 따라서 추후 같은 단축 URL에 대한 요청을 보낼 필요가 있을 때 브라우저는 캐시된 원래 URL로 요청을 보내게 된다.

- 302 Found : 이 응답은 주어진 URL로의 요청이 일시적으로 Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답이다. 따라서 클라이언트의 요청은 언제나 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리디렉션 되어야 한다.

이 두 방법은 각기 다른 장단점을 갖고 있다. 서버 부하를 줄이는 것이 중요하다면 301을 사용하는 것이 좋은데 첫 번째 요청만 단축 URL 서버로 전송될 것이기 때문이다. 하지만 트래픽 분석이 중요할 때는 302 Found를 쓰는 쪽이 클릭 발생률이나 발생 위치를 추적하는데 좀 더 유리할 것이다.

URL 리디렉션을 구현하는 가장 직관적인 방법은 해시 테이블을 사용하는 것이다. 해시 테이블에 <단축URL, 원래URL>의 쌍을 저장한다고 가정한다면, URL 리디렉션은 다음과 같이 구현될 수 있을 것이다.

- 원래 url = hashTable.get(단축url)
- 301 또는 302 응답 Lcoation 헤더에 원래 url을 넣은 후 전송

### [추가 참조]

301과 302는 '3XX Redirection' 클래스에 속한다.
Redirection 클래스에 속하는 상태코드들은 클라이언트를 지정된 위치로 이동시키거나 참조하게 하는 등의 동작을 말한다.
브라우저가 Redirection 상태코드를 만나면 대부분 새로운 URL로 이동하게 된다.

예를들어 기존 웹사이트를 새로운 주소로 옮겼다고 가정해 보자. 이 경우 예전 URL로 접속하면 새로운 주소로 이동하도록 리다이렉트 처리를 추가할 것입니다. 이때 검색엔진이 이전 URL이 보유하던 페이지랭크를 새로운 URL로 전달하게 하려면 301 리다이렉트를 사용해야 한다.

따라서 웹사이트의 도메인을 변경했거나 새로운 URL 구조로 개편했을 때 사용할 수 있습니다.

302 리다이렉트 ?

302 리다이렉트의 의미는 요청한 리소스가 <b>임시적!!</b>으로 새로운 URL로 이동했음(Temporarily Moved)을 나타냅니다. 따라서 검색엔진은 페이지랭킹이나 링크에 대한 점수를 <b>새로운 URL로 옮기지 않으며 기존 URL을 그대로 유지합니다.</b> 즉 검색엔진이 기존 URL이 보유한 페이지랭킹 점수는 그대로 유지하도록 하면서 컨텐트만 새로운 URL에서 조회하도록 해야할 때 유용합니다.

예를들어 쇼핑몰과 같은 전자상거래 사이트를 운영한다고 생각해봅시다. 인기리에 팔리는 제품이 일시적으로 재고가 떨어지거나 혹은 특정한 계절이나 기간에만 한정적으로 파는 제품이였다고 가정해봅시다. 해당 제품이 보유한 사이트랭크를 유지하면서 사용자에게 일시적으로 제품이 품절됐음을 알리려면 어떻게 해야할까요? 이럴 때 301을 사용하거나 혹은 페이지의 컨텐트를 변경하게 되면 사이트랭킹 점수가 달라지게 될 것입니다. 대신 302를 사용하게 되면 검색엔진은 일시적으로 해당 URL의 사이트랭크는 보존하게 되며 사용자는 새로운 URL의 컨텐트를 보게 됩니다.

301,302의 가장 큰 차이점은 기존에 사이트가 가지고 있는 리소스에 이전 유무이다. 301의 경우 우리의 도메인 주소가 바뀜과 동시에 너가 특정 리소스에 대한 응답을 받기 위해서는 다른 url로 이동해야 한다는 것이고 302의 경우엔 기존의 url이 보유하고 있는 리소스는 원본 상태로 두고 해당 url로의 요청을 다른 url로 돌림으로써 해당 요청을 처리하는 것이다. 따라서 301 같은 경우에 캐시로 응답을 저장하면 이후부터는 바로 원래 URL로 요청을 보내서 기존의 단축 URL을 가지고 있는 서버에게는 요청을 보낼 필요가 없고 302의 경우 임시적으로 단축url을 원래url로 우회시키는 것이기 때문에 항상 우선적으로 단축url 서버에 요청을 보내고 원래url로 redirect된다.
