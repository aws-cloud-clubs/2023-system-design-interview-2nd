# 키 - 값 저장소 설계

키 값 저장소는 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스이다.
이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 한다.
키와 값 사이의 이런 연결 관계를 "키-값" 쌍(par) 이라고 지칭한다.

키-값 쌍에서의 키는 유일해야 하며 해당 키에 매달린 값은 키를 통해서만 접근할 수 있다.
키는 일반 텍스트일 수도 있고 해시 값일 수도 있다. 성능상의 이유로, 키는 짧을수록 좋다.

- 일반 텍스트 키 : "last_logged_in_at"
- 해키 키 : 243DDJ34

값은 문자열 혹은 리스트 혹은 객체일 수도 있다.

이번 장에서 다음 연산을 지원하는 키-값 저장소를 설계해 볼 것이다.

put(key,value) : 키-값 쌍을 저장소에 저장한다.
get(key): 인자로 주어진 키에 매달린 갑슬 꺼낸다.

## 분산 키 - 값 저장소

분ㅅ단 키-값 저장소는 분산 해시 테이블이라고도 불린다. 키 값 쌍을 여러 서버에 분산시키는 탓이다. 분산 시스템을 설계할 때는 CAP 정리(Consistency, Availability, Partition Tolerance theorem)를 이해하고 있어야 한다.

### CAP 정리

CAP 정리는 위에서 언급한 일관성, 가용성, 파티션 감내라는 세가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리다. 우선 각 요구사항의 의미부터 명확히 정리하자

- 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어느 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
- 가용성: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
- 파티션 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.

키-값 저장소는 앞서 제시한 3가지 요구사항 가운데 어느 두가지를 만족하느냐에 따라 다음과 같이 분류 가능하다

- CP 시스템 : 일관성과 파티션 감내를 지원하는 키-값 저장소. 가용성 희생
- AP 시스템 : 가용성과 파티션 감내를 지원하는 키-값 저장소. 데이터 일관성 희생
- CA 시스템 : 일관성과 가용성을 지원하는 키-값 저장소 파티션 감내는 지원하지 않는다. 하지만 통상 네트워크 장애는 피할 수 없는 일로 여겨지므로 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.
  그러므로 실세계에선 CA시스템은 존재하지 않는다.

### 실세계의 분산 시스템

분산 시스템은 파티션 문제를 피할 수 없다. 그리고 파티션 문제가 발생 시 우리는 일관성과 가용성 사이에서 하나를 택해야 한다. n3 서버에 장애가 나면 n1,n2에 기록한 데이터는 n3에 전달죄 않는다 역으로 n3에 기록되었으나 아직 n1 및 n2에 전달되지 않은 데이터가 있다면 n1,n2는 오래된 사본을 가지고 있을 것이다.

가용성 대신 일관성을 택한다면 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 n1과 n2 서버 역시 쓰기 연산을 중단시켜야 한다. 그렇게 하면 가용성은 깨진다.

보통 은행권 시스템은 데이터 일관성을 양보하지 않는다. 예를들어, 온라인 뱅킹 시스템이 계좌 최신 정보를 출력하지 못하면 큰 일 날 것이다.

네트워크 파티션으로 인한 오류는 해당 오류가 해결될 때 까지 오류를 반환하게 될 것이다.

하지만 반대로 가용성을 택한다면 설사 낡은 데이터를 반환하는 한이 있더라도 (n3에 기록된 데이터를 모르기에) 계속 읽기 연산을 허용해야 한다. 아울러 n1과 n2는 게속 쓰기 연산을 허용할 것이고 파티션 문제가 해결된 뒤에 새 데이터를 n3에 전송할 것이다.

### 데이터 다중화

높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다. 여기서 N은 튜닝 가능한 값이다. N개 서버를 선정하는 방법은 이러하다. 어떤 키를 해시 링 위에 배치한 후, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 "첫" N개 서버에 데이터 사본을 복사하는 것이다.

### 데이터 일관성

여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다. 정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다. 우선 관계된 정의부터 몇 가지 살펴보자.

- N = 사본 갯수
- W = 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 한다.
- R = 읽기 연산에 대한 정족수 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 한다.

예를 들어보자.

W = 1 이라면 쓰기 연산이 성공했다는 판단을 하기 위해서는 중재자 노드는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야 한다는 뜻이다. ( 해당 데이터가 노드 한개에만 다중화 되었다는 의미는 X)

따라서, s1 서버로부터 성공 응답을 받았다면 s0,s2에게는 응답을 요구하지 않는다. 중재자는 클라이언트와 노드 사이에에서 프락시 역할을 수행한다.

W,R을 1로 잡으면 중재자는 오직 한 대 서버로부터 응답만 수취하면 되니 응답속도는 빠를 것이다. 하지만 W나 R값이 1보다 큰 경우에는 시스템이 보여주는 데이터의 일관성 수준은 향상 될 테지만 중재자의 응답속도는 가장 느린 서버로부터의 응답을 기다려야 하므로 느려질 것이다.

W + R > N 인 경우에는 강한 일관성이 보장된다. 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹친다 (읽기 또는 쓰기에 대한 ACK 메시지를 보내는 노드가 겹침.)

<img src= "https://daeakin.github.io//images/large-system/quorum-consensus.png">

보통 N = 3 , W = R = 2 로 둔다.

강한 일관성을 다성하는 방법은 모든 사본에 현재 쓰기 연산의 결과가 반영될 때 까지 해당 데이터에 대한 쓰기/읽기를 금지하는 것이다. 이 방법은 고가용성 시스템에서는 적합하지 않다. 새로운 요청 처리가 모두 중단된다. 최종 일관성(읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못하는 형태로서 갱신 결과가 결국에는 모든 사본에 동기화되는 모델) 모델을 따를 경우 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨질 수 있는데 , 이 문제는 클라이언트가 해결해야 한다. 클라이언트측에서 데이터의 버전 정보를 활용해 일관성이 깨진 데이터를 읽지 않도록 한다.

### 비 일관성 해소 기법 : 데이터 버저닝

데이터 다중화 시 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아진다.

버저닝과 백터 시계는 그 문제를 해소하기 위해 등장한 기술이다.

버저닝은 데이터를 변경할 때 마다 해당 데이터의 새로운 버전을 만든다. 따라서 각 버전의 데이터는 변경 불가능하다.

데이터 일관성이 깨지는 예시는 다음과 같다.

<img src="https://daeakin.github.io//images/large-system/versioning.png">
<img src="https://daeakin.github.io//images/large-system/versioning-2.png">

n1,n2서버가 있고 두 다 name:joh 이라는 키-값을 가지고 있다고 하자. n1 서버에서는 jhonNewYork 으로 바뀌었고 n2서버에서는 jhonFlorida라고 바뀌었다고 하자. 그리고 이 두 연산이 동시에 이루어진다고 하자. 이렇게 되면 충돌이 발생한다. 각각의 버전을 v1,v2라고 하자.

이 문제를 해결하려면 충돌을 발견하고 자동으로 해결해 낼 버저닝 시스템이 필요하다.

백터 시계는 이런 문제를 푸는데 보편적으로 사용되는 기술이다.

백터 시계는 [서버,버전]의 형식으로 순서쌍을 데이터에 매단 것이다. 어떤 버전이 선행 버전인지, 후행 버전인지 아니면 다른 버전과의 충돌 유무를 파악하는데 사용된다.

백터 시계는 다음과 같은 동작으로 이루어진다

- [Si, Vi]가 있으면 vi를 증가시킨다.
- 그렇지 않으면 새 항목 [Si,1]을 만든다.

<img src="https://daeakin.github.io//images/large-system/versioning-3.png">

백터 시계를 사용한다면 어떤 버전 X가 버전 Y의 이전 버전인지 (충돌이 없는지) 쉽게 판단 가능하다.
버전 Y에 포함된 모든 구성요소의 값이 X에 포함된 모든 구성요소 값보다 같거나 큰지만 보면 된다.
예를들어, 백터 시계 D([s0,1], [s1,1])은 D([s0,1],[s1,2])의 이전 버전이다. 따라서 두 데이터 사이에 충돌은 없다.

그러나 백터 시계를 사용해 충돌을 감지하고 해소하는 방법에는 두 가지 단점이 있다.

- 충돌 감지 및 해소 로직이 클라이언트의 시스템에 기록되어야 하므로 클라이언트 구현이 복잡해진다.
- 두 번째는 [서버:버전]의 순서쌍 갯수가 굉장히 빨리 늘어난다.

이 문제를 해결하려면 그 길이에 어떤 임계치를 설정하고 임계치 이상으로 길이가 길어지면 오래된 순서쌍을 백터 시계에서 제거하도록 해야한다. 그러나 이렇게 하면 버전 간 선후 관계가 정확하게 결정될 수 없기에 충돌 해서 과정의 효율성이 낮게 된다. 하지만 다이나모 데이터베이스 관계된 문헌에서는 실제 그런 문제가 발생한 적이 없어 백터시계도 나쁘지 않은 선택이 될 수 있다고 본다.

### 쓰기 경로

<img src="https://daeakin.github.io//images/large-system/cassandra-read.png">

1. 쓰기 요청이 커밋 로그 파일에 기록된다.
2. 데이터가 메모리 캐시에 기록된다.
3. 메모리 캐시가 가득차거나 사전에 정의된 어떤 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다. SSTable은 Sorted-String Table의 약어로 <키,값> 의 순서쌍을 정렬된 리스트 형태로 관리하는 테이블이다.

### 읽기 경로

<img src="https://daeakin.github.io//images/large-system/cassandra-read-2.png">

1. 일긱 요청을 받은 노드는 데이터가 캐시에 있는지 부터 살핀다.
2. 있는 경우 캐시에서 데이터를 반환해 클라이언트에게 응답한다.
3. 데이터가 메모리에 없는 경우에는 디스크에서 가져와야 한다. 이때 블룸 필터 (Bloom Filter)를 활용해 효율적으로 데이터를 수취한다.

데이터가 없으면,

블룸 필터로 가서 해당 필터를 통해 SSTable 내 키의 보관 위치를 찾아낸다.
SSTable로 들어가 해당 키의 값을 가져오고 클라이언트에게 반환한다.

### 추가 공부 - SSTable (https://www.scylladb.com/glossary/sstable/)

ref : https://nicewoong.github.io/development/2018/02/11/cassandra-internal/

<img src="https://www.scylladb.com/wp-content/uploads/sstable-diagram.png">

SSTable(Sorted Strings Table)은 ScyllaDB, Apache Cassandra 및 기타 NoSQL 데이터베이스에서 memtable에 저장된 메모리 내 데이터를 가져와 빠른 액세스를 위해 순서를 지정하고 순서가 지정된 영구 파일 형식으로 디스크에 저장하는 데 사용되는 영구 파일 형식. 불변의 파일 세트. 불변이란 SSTable이 수정되지 않는다는 것을 의미합니다. 나중에 데이터가 업데이트되면 새 SSTable로 병합되거나 삭제됩니다.

- memtable 이란 ? (캐시)
  memtable 은 메모리에서의 데이터 구조다. 쓰기(write) 요청이 들어오면 메모리의 memtable 에 먼저 써지고 그 다음에 선택적으로 logfile 에 써진다. logfile 은 저장장치에 순차적으로 쓰이는 파일이다.

SSTable은 디스크에 지속적이고 순서가 있으며 <b>변경할 수 없는 파일 세트로</b> 저장됩니다. 이는 <b>memtable 플러시에 의해</b> 생성되고 압축에 의해 삭제됩니다.

데이터베이스의 목적은 데이터를 지속적이고 효율적으로 저장하는 것입니다. 해당 스토리지는 시스템이 종료되거나 오류가 발생할 때 데이터가 손실되지 않도록 내구성이 있어야 합니다. 모든 데이터를 메모리에만 보관하는 것은 빠르지만 내구성이 떨어집니다. 모든 업데이트를 스토리지에 즉시 기록하는 것은 규모에 따라 매우 느리고 비효율적입니다.

이것이 바로 Memtable과 SSTable을 이해해야 하는 부분입니다. 데이터가 커밋되면 ScyllaDB 또는 Cassandra는 추가만 허용하는 파일인 커밋로그에 변경 사항을 저장하므로 쓰기가 빠릅니다. 동시에 데이터는 memtable이라는 키/열 데이터의 메모리 내 캐시에 기록됩니다. <b>주기적으로 memtable은 디스크의 SSTable 형식으로 영구 저장소로 플러시됩니다.</b> <b>SSTable은 데이터베이스에 저장된 전체 데이터의 구성 요소 역할을 합니다.</b> <b>SSTable은 변경할 수 없으므로 데이터를 업데이트하면 기존 SSTable 파일을 변경하는 대신 새 SSTable 파일이 생성됩니다.</b>

각 SSTable에 대해 데이터베이스는 <b>인덱스 파일과 데이터 파일</b>을 생성합니다. 인덱스 파일은 정렬된 데이터 파일에서 데이터를 더 빠르게 찾는 데 도움이 됩니다.

SSTable은 LSM(Log-Structured Merge) 트리 데이터 구조 형식을 사용합니다. 이 형식은 기존 B-트리(“비 트리”로 발음) 형식보다 쓰기 작업이 많고 빠르게 증가하는 매우 큰 데이터 세트에 더 효율적입니다.

데이터가 계속해서 작성되고 업데이트됨에 따라 더 많은 불변 SSTable 파일이 생성됩니다. 따라서 서로 다른 버전의 데이터를 포함하는 동일한 레코드가 디스크의 서로 다른 SSTable 파일에서 발견될 수 있습니다. 시스템은 이러한 레코드 중 어떤 것이 가장 최신인지 이해하고 최신 버전의 쿼리 요청에만 응답합니다. 그러나 오래된 것을 제거할 수 있는 방법이 없으면 저장된 SSTable 수와 데이터 볼륨이 매우 높아져 디스크가 가득 차게 됩니다.

<b>압축은 기존 SSTable에서 발견된 데이터를 사용하여 완전히 새로운 파일을 작성하는 프로세스입니다.</b> 이 프로세스는 사용되지 않는 레코드를 <b>중복 제거</b>하고 다른 SSTable의 동일한 키에 대한 최신 변경 사항만 기록하여 새 SSTable 파일을 작성합니다. 삭제된 행(삭제 표시라는 표시로 표시됨)이나 삭제된 전체 열도 정리되고 압축된 SSTable 파일에 대한 새 인덱스가 생성됩니다.
